The dashboard for the given university is divided into two parts (the first one is the shared dashboard of all the existing spaces for the university (all the spaces that we're created and not deleted) by all the users of the particular dashboard. The second part is the user-private dashvoard where the spaces that he/she tracks are displayed - the user can only update the spaces from his private dashboard

\subsection*{Points of possible misuse of the system}
As we described previously, the dashboards along with the list of universities supported by the system depend on the users (the community) - which implies that there might be cases when the "bad" users try to crash the system in some form of DDos or try to provide incorrect information.

\subsubsection*{DDOS}
To overcome the ddos kind of attacks where the user submits subsequent request to support a new university - we need to employ a limited number of pending universities (e.g only the universities we can store in cache - for that we can integrate REDIS into our system).

Since similar things can be done with the followed spaces of particular university - we need to add a limitation of the number of spaces the user can track at the same time (the private-dashboard e.g. 20 (the number can be changed depending on the user feedback) - for now we believe that this number is the maximal number of spaces the user can track effectively - greater than this number the dashboard becomes unreadable.

\subsubsection*{Misreport}
the first thing is that the users can edit the existing spaces (that they added to the dasboard e.g. update the has_wifi parameter or price range - to prevent misreport we need to add a voting system - in the sense that the users who intends to make an edit submits an edit and the users vote on it (if some threshold of positive answers is reached - the edit is made (again the threshold is to be determined, but for now we think of 10% of users that track the given space)

The other things is that the users can report the occupation in an incorrect way - for this we need to add somekind of a user reporting system where the users who observe the reported occupation can report the misuse (the report can only be submitted no longer than 5 minutes after the person reported the occupation. And in the case of multiple reports (e.g. 3) the user can be banned from reporting the occupation for some period of time (the field can report is False) -  this timely ban can be implemented by having cron job (or similar) - that after the user (if the user was temporary banned more than 3 times - he/she get a permanent ban on writing the occupation)




\subsection*{Implementation Plan}
Since the application is split into Django applications - we can build the implementation considering the dependencies they impose on each other (we can order them in the following way) 

core (central), users + universities (models are interdependent), reports (this is a "security measure" - so can be build the last)

Core can be split into two parts (pre authenticated, authenticated) - authenticated can be only effectively build after the users + universities is made

Thus:

Core (pre-authenticated)

Users Model, Universities Model

Users Authentication

Email Verification

Core (authenticated)

Reports system


TODO:

db schema add verification (user_id, timestamp, token), reports (user_id_reported, user_id_submitted_report, timestamp)
update the user table by adding can_update_occupation number_of_times_being_temporary_banned field (the idea is that reports table serves as a log sort of - where we can check the reports and decide if we need to temporary ban a user or not (maybe can be implemented just as a log file ---- need to check)


\subsection*{Main Learning}
The main learning of this project for me is the considerations related to the community-incentives that is how to design a system where the user still have the freedom of managing it, but the misuse is limited. The other thing is the considerations on the choice of authentication method (why the simple authentication without email verification is not sufficient in this case.

